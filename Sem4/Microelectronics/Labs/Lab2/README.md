# Лабораторная работа №2: Исследование функционирования схем регистров FIFO, LIFO и кэш-памяти<br><br><br>


## Fifo, Lifo:<br>
### 1. FIFO(first in, first out) - очередь. Записываем: 1, 2 ,3. Чтение происходит в следующем порядке: 1, 2, 3.<br>
### 2. LIFO(last in, first out) - по факту просто стек. Записываем: 1, 2 ,3. Чтение происходит в следующем порядке: 3, 2, 1.<br><br>

## Описание элементов схемы:<br>
### fiforeg - основной вычислитель для FIFO. На вход поступают данные, сигналы чтения и записи, и счётчики чтения и записи. Внутри файла содержаться 8 "ячеек памяти". Соответственно, когда мы что-либо записываем, счётчик записи увеличивается, и последующая запись происходит в следующую ячейку.<br>
### liforeg - практически аналогичен fiforeg.<br><br>

## Описание пинов:<br>
### RD - входное бинарное число, сигнализирующее о чтение из FIFO и LIFO.<br>
### WR - входное бинарное число, сигнализирующее о записи в FIFO и LIFO.<br>
### Reset - входное бинарное число, необходимое для сброс (сброс происходит в виде обнуления счётчиков чтения и записи).<br>
### DI[7 ..0] - входное однобайтовое число, содержащий входные данные, для хранения в FIFO и LIFO.<br>
### Full - выходное бинарное число, сигнализирующее о том, что все ячейки FIFO и LIFO заполнены и необходимо прекратить запись данных.<br>
### Empty - выходное бинарное число, сигнализирующее о том, что все ячейки FIFO и LIFO пусты и необходимо прекратить чтение данных.<br>
### DO[7 ..0] - выходное однобайтовое число, содержащий данные, которые хранились в FIFO и LIFO.<br><br>

## Описание папок и файлов:<br>
### В fifoLifoGDF содержатся gdf файлы с FIFO и LIFO, необходимые для их работы компоненты и scf файлы для их тестирования. Тестирование и компиляция проводятся в MaxPlusII.<br>
### В fifoLifoCode содержатся vhd файлы с FIFO и LIFO, а так же vwf файл, для тестирования. vwf файл подходит и для FIFO и для LIFO, так как все пины аналогичны. Тестирование и компиляция проводятся в QuartusII.<br><br>

## Требование к тестированию:<br>
### Необходимо записывать данные с частотой в 2 раза выше, чем чтение. После возникновения сигнала Full, необходимо прекратить запись (в том числе и подачу любых данных на DI, иначе ракета упадёт и вас посадят) и читать до сигнала Empty.<br><br>

## Вопросы:
### 1. Каким образом возникают Full и Empty? И в FIFO и в LIFO Full возникает при WR = 1, Empty при RD = 1. В FIFO Full и Empty возникают когда счётчики чтения и записи совпадают. В LIFO, Full возникает, когда счётчик равен 7, Empty, когда счётчик равен 0.<br>
### 2. Чем отличаются схемы FIFO и LIFO? В FIFO 2 счётчика: для чтения и для записи. В LIFO счётчик, который увеличивается на записи, и уменьшается на чтение.<br>
### 3. Где используются FIFO и LIFO? FIFO используется для связи между процессором и внешними устройствами. Например скорость вычисления процессора 1000, а скорость приёма внешнего устройства 10. Процессор вычисляет пока FIFO не заполниться, после чего переключается на обработку другого устройства. Про LIFO он не спрашивал, но можно вспомнить АиСД, ТП и т.д. и сказать про командный стек.<br><br><br>

## Кэш:<br>
### Кэш состоит из ячеек, хранящих данные, и реальный физический адрес, из которого эти данные взяты. Необходимо для хранения данных из RAM, которые часто используются.<br><br>

## Описание элементов схемы:<br>
### cacheBlock - ячейка кэшированной памяти. Хранит данные и адрес, которые в неё записали. Вырабатывает Hit сигнал, если входящий адрес совпадает с хранящемся.<br><br>

## Описание пинов:<br>
### RD - входное бинарное число, сигнализирующее о чтение из кэша.<br>
### WR - входное бинарное число, сигнализирующее о записи в кэш.<br>
### CLK - входное бинарное число, просто таймер.<br>
### inAddr[7 ..0] - входное однобайтовое число, содержащий физический адрес ячейки, откуда данные записываются в кэш.<br>
### inData[7 ..0] - входное однобайтовое число, содержащий входные данные, из ячейки памяти.<br>
### Hit - выходное бинарное число, равен 1, если какая-либо из ячеек содержит адрес, совпадающий с входным.<br>
### outAddr[7 ..0] - выходное однобайтовое число, всегда выводит значение из inAddr.<br>
### outData[7 ..0] - выходное однобайтовое число, при (RD = 1)(Hit = 1) выводит данный из ячейки кэшированной памяти, в остальных случаях выводит значение из inData.<br>
### Дополнительные пины, который Амосов требует:<br>
### localAddrs[7 ..0][7 ..0] - выходной массив однобайтовых чисел, содержащий все адреса хранящиеся в ячейках памяти.<br>
### localData[7 ..0][7 ..0] - выходной массив однобайтовых чисел, содержащий все данные хранящиеся в ячейках памяти.<br><br>

## Описание папок и файлов:<br>
### В cache содержатся bdf файлы с кэшом, ячейками кэшированной памяти и кодером, а так же vwf файл необходимый для тестирования. Тестирование и компиляция проводятся в QuartusII. Папка old содержит проект до добавления localAddrs и localData<br><br>

## Требование к тестированию:<br>
### 1. Забиваем все ячейки памяти данными и адресами, Hit = 0.<br>
### 2. Пишем новые данные с неизвестном адресу, Hit = 0.<br>
### 3. Читаем из по известному адресу, Hit = 1.<br>
### 4. Читаем адресу, который мы вводили первым, он уже затёрт адресом из пункта 2, так что Hit = 0.<br>
### 5. Пишем новые данные по известному адресу, Hit = 1.<br><br>

## Вопросы:<br>
### Да кто его знает?
